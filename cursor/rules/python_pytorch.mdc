# Cursor Project Rules — Python/PyTorch

## Coding Standards
- Python 3.10+; type hints required in new/edited code.
- Docstrings (Google/Numpy style). Keep functions short and cohesive.
- Prefer functional clarity over micro-optimizations.

## PyTorch Best Practices
- Device handling: accept `device` in configs; move tensors/models once; avoid repeated `.to(device)`.
- Determinism where possible: set seeds; enable cudnn deterministic flags when relevant.
- Tensors normalized consistently (decide on [-1,1] or [0,1] and document).
- No silent shape/range mismatches—validate early with clear messages.

## StyleGAN2 Handling
- Loader provides:
  - `load_generator(weights_path, device)` → `G`.
  - `mean_w(G)` computation (sample-based if not packaged).
  - A forward that supports latent in **W** or **W+** (per-layer).
- Abstractions prevent coupling inverter to a specific checkpoint format.

## Losses & Metrics
- `losses/l2.py`: simple MSE with proper normalization and shape checks.
- `losses/lpips_loss.py`: LPIPS via `lpips` package; batch-safe; works on CUDA/CPU.
- `engine/metrics.py`: PSNR/SSIM/LPIPS metrics (distinct from training loss).
- All expose clean, minimal interfaces; unit-tested in `tests/`.

## Inversion Engine
- `engine/inverter.py`:
  - `run_inversion(G, x, config)` with options:
    - latent_space ∈ {W, W+}
    - init ∈ {mean_w, random, encoder (later stage)}
    - loss ∈ {l2, lpips}
    - optimizer = Adam (default), steps, lr, optional L-BFGS
  - Track `history` (loss per step) and return `(z_star, recon, history)`.
  - Log every N steps; support early-stop (optional).

## CLI
- `invert.py`:
  - Args: input image/folder, weights path, loss, latent_space, init, steps, lr, seed, device.
  - Saves: reconstructions, diff panels, metrics JSON, loss curve.
  - Non-zero exit codes on fatal errors.

## Testing
- `pytest -q` must pass:
  - Losses sanity checks (CPU; small tensors).
  - Metrics deterministic tests on toy arrays.
  - Toy inverter test (dummy G) shows loss decreasing with steps.

## Logging & Errors
- Use Python `logging` with clear levels; print step/loss every N steps.
- Raise explicit `ValueError`/`RuntimeError` for misconfigurations; no cryptic stack traces.
